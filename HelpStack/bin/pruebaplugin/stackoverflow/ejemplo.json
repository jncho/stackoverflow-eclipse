{"items":[{"tags":["java","io"],"answers":[{"is_accepted":false,"score":0,"answer_id":30143927,"body":"<blockquote>\n  <p>does java support to read .file s with this code?</p>\n</blockquote>\n\n<p>No, since <code>c:/test.txt</code> is hard coded. If it wouldn't yes it would support it.</p>\n"},{"is_accepted":false,"score":0,"answer_id":30143940,"body":"<p>Yes it's possible if you write <code>is = new FileInputStream(\"c:/test.file\");</code></p>\n"},{"is_accepted":false,"score":0,"answer_id":30143950,"body":"<p>Yes, it reads any file you give it the same way. You can pass any file path with any extension to the <code>FileInputStream</code> constructor.</p>\n"},{"is_accepted":true,"score":1,"answer_id":30143996,"body":"<p>The extension of a file is totally irrelevant. Extensions like <code>.txt</code> are mere conventions to help your operating system choose the right program when you open it.</p>\n\n<p>So you can store text in any file (<code>.txt</code>, <code>.file</code>, <code>.foobar</code> if you are so inclined...), provided <em>you</em> know what kind of data it contains, and read it accordingly from your program.</p>\n\n<p>So yes, Java can read <code>.file</code> files, and your code will work fine if that file contains text.</p>\n"},{"is_accepted":false,"score":0,"answer_id":30144007,"body":"<p>Anyone can read any file you want, since a file is just a sequence of bytes. The extension tells you in what format the bytes should be read, so when we have a <code>.txt</code> file we know that this is a file with sequences of characters.</p>\n\n<p>When you have a file format called <code>.file</code> we know that it should be (according to you) a 9x9 set of characters. This way we know what to read and do that.</p>\n\n<p>Since the <code>.file</code> format is characters I would say yes, you can read that with your code for instance with this:</p>\n\n<pre><code>public String[] readFileFormat (final File file) throws IOException {\n    if (file.exists()) {\n        final String[] lines = new String[9];\n        final BufferedReader reader = new BufferedReader ( new FileReader( file ) );\n        for ( int i = 0; i &lt; lines.length; i++ ) {\n            lines[i] = reader.readLine();\n            if (lines[i] == null || lines[i].isEmpty() || lines[i].length() &lt; 9)\n                throw new RuntimeException (\"Line is empty when it should be filled!\");\n            else if (lines[i].length() &gt; 9)\n                throw new RuntimeException (\"Line does not have exactly 9 characters!\");\n        }\n        reader.close();\n        return lines;\n    }\n    return null;\n}\n</code></pre>\n"},{"is_accepted":false,"score":0,"answer_id":49734255,"body":"<p>The extension is totally irrelevant, so it can be .file, .txt or whatever you want it to be. </p>\n\n<p>Here is an example of reading in a file with BuffereInputStream that reads a file of type .file. This is part of a larger guide that discusses <a href=\"https://funnelgarden.com/java_read_file/\" rel=\"nofollow noreferrer\">15 ways to read files in Java</a>.</p>\n\n<pre><code>import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class ReadFile_BufferedInputStream_Read {\n  public static void main(String [] pArgs) throws FileNotFoundException, IOException {\n    String fileName = \"c:\\\\temp\\\\sample-10KB.file\";\n    File file = new File(fileName);\n    FileInputStream fileInputStream = new FileInputStream(file);\n\n    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream)) {\n      int singleCharInt;\n      char singleChar;\n      while((singleCharInt = bufferedInputStream.read()) != -1) {\n        singleChar = (char) singleCharInt;\n        System.out.print(singleChar);\n      }\n    }\n  }\n}\n</code></pre>\n"}],"is_answered":true,"view_count":469,"accepted_answer_id":30143996,"answer_count":6,"score":0,"creation_date":1431198231,"question_id":30143907,"title":"Read file in java","body":"<p>I have file in my computer which have <code>.file</code> extension , I want to read it 9 character by 9 character. I know that I can read file by this code, but what should I do when my file is not <code>.txt</code>?does java support to read <code>.file</code> s with this code?</p>\n\n<pre><code>                InputStream is = null;\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                is = new FileInputStream(\"c:/test.txt\");\n                // create new input stream reader\n                isr = new InputStreamReader(is);\n                // create new buffered reader\n                br = new BufferedReader(isr);\n                // creates buffer\n                char[] cbuf = new char[is.available()];\n                for (int i = 0; i &lt; 90000000; i += 9) {\n                // reads characters to buffer, offset i, len 9\n                br.read(cbuf, i, 9);}\n</code></pre>\n"},{"tags":["java","io","java-8"],"answers":[{"is_accepted":true,"score":3,"answer_id":37137258,"body":"<p>The <code>UncheckedIOException</code> is wrapping a <code>MalformedInputException</code> - that is the unlying error. The JavaDoc for that says:</p>\n\n<blockquote>\n  <p>Checked exception thrown when an input byte sequence is not legal for\n  given charset, or an input character sequence is not a legal\n  sixteen-bit Unicode sequence.</p>\n</blockquote>\n\n<p>So your <code>file.txt</code> does not contain valid UTF-8 and is causing the UTF-8 decoder to report an error.</p>\n"}],"is_answered":true,"view_count":3144,"accepted_answer_id":37137258,"answer_count":1,"score":3,"creation_date":1462879014,"question_id":37136973,"title":"Java 8 read file using streams java.io.UncheckedIOException","body":"<p>I am trying to use streams to read a file but I cannot get past an exception. I have been looking around but I just can't understand why it's being thrown.</p>\n\n<p>The file I am going to read is <code>file.txt</code> and it's encoded with UTF-8.</p>\n\n<p>I am reading it using <code>Files.lines()</code>:</p>\n\n<pre><code>String path = FileWordCount.class.getResource(\"file.txt\").getPath().substring(1);\n\nFiles.lines(Paths.get(path), Charset.forName(\"UTF-8\")).forEach(System.out::println);\n</code></pre>\n\n<p>When trying to read the file I am getting the following exception:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Exception in thread \"main\" java.io.UncheckedIOException: java.nio.charset.MalformedInputException: Input length = 1\n[...]\nCaused by: java.nio.charset.MalformedInputException: Input length = 1\n</code></pre>\n\n<p>Normally I don't post simple questions about exceptions but I just figure this one out.</p>\n"},{"tags":["java","io","copy","javafx-2"],"answers":[{"is_accepted":false,"score":1,"answer_id":37847859,"body":"<p>Maybe the file is not done copying yet.  It could take the OS a while to copy the file.   The <code>copy</code> method might return before the copy is complete. </p>\n"},{"is_accepted":true,"score":0,"answer_id":37848009,"body":"<p>Without seeing more code I would say that your issue is this line <code>Image image = new Image(bild);</code>.</p>\n\n<p>Also <code>\"/images/\"+copy.getPath()</code> is not the same as <code>relativePath</code>, are you using them both correctly? Try this to check if there is an issue:</p>\n\n<pre><code>System.out.println(\"/images/\"+copy.getPath());\nSystem.out.println(relativePath);\nSystem.out.println(copy.getAbsolutePath());\n</code></pre>\n\n<p>Was your issue caused by an incorrect path?</p>\n\n<p>Now try something a bit like this to load your image (Note how ImageIO is used):</p>\n\n<pre><code>System.out.println(\"Does file exist: \"+ copy.exists());\nSystem.out.println(\"Is file locked: \"+ copy.canWrite());\nwhile (copy.canWrite() != true){\n    //stall your application until the file is accessible.\n}\n//now load the file\nImage image = ImageIO.read(copy);\n</code></pre>\n\n<p>This answer has excellent info on checking for a locked file:\n<a href=\"https://stackoverflow.com/a/1500521/1270000\">https://stackoverflow.com/a/1500521/1270000</a></p>\n"}],"is_answered":true,"view_count":48,"accepted_answer_id":37848009,"answer_count":2,"score":0,"creation_date":1466035135,"question_id":37847706,"title":"Java: Can&#39;t read file I copied during session, works fine after program restart","body":"<p>i am copying a file like this: </p>\n\n<pre><code>            File copy = new File(file.getName());\n            // path relative to current working directory\n            Path relativePath = Paths.get(\"src/main/resources/images/\",  copy.getPath());\n            java.nio.file.Files.copy(\n                    file.toPath(), // input path\n                    relativePath, // target path\n                    java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n\n            logger.info(\"Copy file to path {}\", relativePath);\n            // save path for NPC\n            currentImagePath = \"/images/\"+copy.getPath();\n</code></pre>\n\n<p>and then save the path to the database. When I try to open the copied file like this:</p>\n\n<pre><code>            Image image = new Image(bild);\n</code></pre>\n\n<p>(bild is the currentImagePath from before), I get an Exception saying that it was an invalid URL or the resource was not found. However, if I end the program and start it anew, opening the file works without a problem. Is there a solution to this? </p>\n"},{"tags":["java","io","classpath","java-7"],"answers":[{"is_accepted":false,"score":1,"answer_id":14692977,"body":"<p>You should look at <code>ClassLoader.getResource()</code>. This returns a URL which represents the resource. If it's local to the file system, it will be a <code>file://</code> URL. At that point you can strip off the scheme etc., and then you have the file name with which you can do whatever you want.</p>\n\n<p>However, if it's not a file:// path, then you can fall back to the normal InputStream.</p>\n"},{"is_accepted":false,"score":2,"answer_id":14693024,"body":"<p>As far as I understand, what you want is to open a <code>ReadableByteChannel</code> to your resource, so you can use NIO for reading it.</p>\n\n<p>This should be a good start, </p>\n\n<pre><code>// Opens a resource from the current class' defining class loader\nInputStream istream = getClass().getResourceAsStream(\"/filename.txt\");\n\n// Create a NIO ReadableByteChannel from the stream\nReadableByteChannel channel = java.nio.channels.Channels.newChannel(istream);\n</code></pre>\n"},{"is_accepted":true,"score":7,"answer_id":14693028,"body":"<p>A Path represents a file on the file system. It doesn't help to read a resource from the classpath. What you're looking after is a helper method that reads everything fro a stream (more efficiently than how you're doing) and writes it to a byte array. Apache commons-io or Guava can help you with that. For example with Guava:</p>\n\n<pre><code>byte[] array = \n    ByteStreams.toByteArray(this.getClass().getClassLoader().getResourceAsStream(resourceName));\n</code></pre>\n\n<p>If you don't want to add Guava or commons-io to your dependencies just for that, you can always read their source code and duplicate it to your own helper method.</p>\n"},{"is_accepted":false,"score":27,"answer_id":28860203,"body":"<p>This works for me. </p>\n\n<pre><code>import java.nio.file.Files;\nimport java.nio.file.Paths;\n\n// fileName: foo.txt which lives under src/main/resources\npublic String readFileFromClasspath(final String fileName) throws IOException, URISyntaxException {\n    return new String(Files.readAllBytes(\n                Paths.get(getClass().getClassLoader()\n                        .getResource(fileName)\n                        .toURI())));\n}\n</code></pre>\n"}],"is_answered":true,"view_count":23691,"accepted_answer_id":14693028,"answer_count":4,"score":13,"creation_date":1360000736,"question_id":14692600,"title":"Read file from classpath with Java 7 NIO","body":"<p>I've googled around for quite a while for this, but all the results point to pre-Java 7 NIO solutions. I've used the <a href=\"http://docs.oracle.com/javase/tutorial/essential/io/file.html\" rel=\"noreferrer\">NIO stuff</a> to read in files from the a specific place on the file system, and it was so much easier than before (<code>Files.readAllBytes(path)</code>). Now, I'm wanting to read in a file that is packaged in my WAR and on the classpath. We currently do that with code similar to the following:</p>\n\n<pre><code>Input inputStream = this.getClass().getClassLoader().getResourceAsStream(fileName);\nByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n\n/* iterate through the input stream to get all the bytes (no way to reliably find the size of the \n *     file behind the inputStream (see http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html#available()))\n */\nint byteInt = -1;\ntry\n{\n    byteInt = inputStream.read();\n    while (byteInt != -1)\n    {\n        byteStream.write(byteInt);\n        byteInt = inputStream.read();\n    }\n\n    byteArray = byteStream.toByteArray();\n    inputStream.close();\n    return byteArray;\n}\ncatch (IOException e)\n{\n    //...\n}\n</code></pre>\n\n<p>While this works, I was hoping there was an easier/better way to do this with the NIO stuff in Java 7. I'm guessing I'll need to get a <a href=\"http://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html\" rel=\"noreferrer\">Path</a> object that represents this path on the classpath, but I'm not sure how to do that. </p>\n\n<p>I apologize if this is some super easy thing to do. I just cannot figure it out. Thanks for the help.</p>\n"},{"tags":["java","file","io"],"answers":[{"is_accepted":true,"score":1,"answer_id":26580779,"body":"<p>Correct. If you want a <code>Scanner</code> wrapping a <code>File</code> pass a <code>File</code> in the constructor. Change this</p>\n\n<pre><code>Scanner scan = new Scanner(args[0]); \n</code></pre>\n\n<p>to</p>\n\n<pre><code>Scanner scan = new Scanner(new File(args[0])); \n</code></pre>\n\n<p>The constructor for <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#Scanner%28java.lang.String%29\" rel=\"nofollow\"><code>Scanner(String)</code></a> says,</p>\n\n<blockquote>\n  <p>Constructs a new <code>Scanner</code> that produces values scanned from the specified string.</p>\n</blockquote>\n\n<p>While the constructor for <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#Scanner%28java.io.File%29\" rel=\"nofollow\"><code>Scanner(File)</code></a> says,</p>\n\n<blockquote>\n  <p>Constructs a new <code>Scanner</code> that produces values scanned from the specified file. </p>\n</blockquote>\n"}],"is_answered":true,"view_count":108,"accepted_answer_id":26580779,"answer_count":1,"score":0,"creation_date":1414379926,"question_id":26580729,"title":"Read file into string - Java","body":"<p>I want to read an entire file into a string. The file however is in the program arguments. I have been trying to use Scanner in order to:</p>\n\n<pre><code>Scanner scan = new Scanner(args[0]);  \n        scan.useDelimiter(\"\\\\Z\");  \n        String content = scan.next(); \n        System.out.println(content);\n</code></pre>\n\n<p>My result is just the name of the file that is in \"args[0]\" instead of the actual contents of the file. </p>\n\n<p>I figured a loop would not work since I am not hardcoding the file into the program. </p>\n"},{"tags":["java","file","parameters","io","java.util.scanner"],"answers":[{"is_accepted":false,"score":0,"answer_id":25991956,"body":"<p>It is possible to do it that way, but then you'll have to pass the filename into the commandline when starting the program. Like this:</p>\n\n<p>java [program] [filename]</p>\n\n<p>Another solution is hardcoding:</p>\n\n<p>File inputFile = new File (\"filename\");</p>\n"},{"is_accepted":true,"score":1,"answer_id":25992010,"body":"<p>I would suggest you to pass <code>String</code> means file path to the method in that sense after reading from file the <code>Objects</code> gets garbage collected after the execution of method while in main method you may want to perform some other stuff and <code>File</code> object remain accessible until the execution of main method.</p>\n\n<p><strong><em>What if</em></strong> you want to read more than one file and you are passing multiple command line argument ? So passing <code>String</code> to method sounds convenient as it will allow you to manage File object.In this situation creating <code>File</code> Objects and than passing it to method becomes more time consuming.</p>\n\n<p>So it Should be...</p>\n\n<pre><code>        public static void main(String[] args){\n            Read readFile = new Read(); \n            readFile.doSomething(args[0]);\n            readFile.doSomething(args[1]);//You can read multiple files\n            ....\n        }\n        public void doSomething (String inputFile) throws FileNotFoundException{\n            File inputFile = new File (inputFile);\n            //Read File With Scanner\n        }\n</code></pre>\n"},{"is_accepted":false,"score":0,"answer_id":25992382,"body":"<p>As stated above these are the two ways but note your harcoded file must be present in the project where your packages reside.</p>\n"}],"is_answered":true,"view_count":4322,"accepted_answer_id":25992010,"answer_count":3,"score":0,"creation_date":1411465005,"question_id":25991705,"title":"How to use Scanner to read file and pass it to a method in Java","body":"<p>I am confused with how to use Scanner to read a file (given in command line argument), and use the information from that file in a method. What's the best way to do this?</p>\n\n<p>I know there must be numerous errors in my code. i.e. Which type of parameter shall I pass to the method, string or file? I have commented my questions in the code. Many thanks!</p>\n\n<pre><code>public class Read {\nint [] store;\n\npublic Read() {\n    store = new int[200];\n}\npublic static void main(String[] args) throws FileNotFoundException {\n    File inputFile = new File (args[0]); //shall I declare a File variable here?\n    Read readFile = new Read(); \n    readFile.doSomething(inputFile);//Should the parameter of doSomething be String type? \n}\npublic void doSomething (String inputFile) throws FileNotFoundException{\n    Scanner sc;  //I intend to use the info. from the file to do something here\n    sc = new Scanner(new FileReader(inputFile));\n    while (sc.hasNext()){\n        .....\n    }\n }\n}\n</code></pre>\n"},{"tags":["java","sockets","io","inputstream"],"answers":[{"is_accepted":false,"score":-1,"answer_id":9588405,"body":"<p>Using <code>InputStream</code> you can read in an array of given size and limit the reading to this size.</p>\n\n<p>Read here: <a href=\"http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#read%28byte%5B%5D%29\" rel=\"nofollow\">http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html</a></p>\n"},{"is_accepted":false,"score":6,"answer_id":9588409,"body":"<p>You can use the appropriate <code>read()</code> method from the input stream, for example <a href=\"http://docs.oracle.com/javase/1.4.2/docs/api/java/io/FileInputStream.html#read%28byte%5B%5D%29\" rel=\"noreferrer\"><code>FileInputStream</code></a> supports a <code>read(byte[])</code> to read a chunk of bytes.</p>\n\n<p>something like: You may want to wrap the input stream in a <code>BufferedInputStream</code> if you wanted to guarantee 512 byte blocks (the constructor takes a block size argument).</p>\n\n<pre><code>byte[] buffer = new byte[512];\nFileInputStream in = new FileInputStream(\"some_file\");\nint rc = in.read(buffer);\nwhile(rc != -1)\n{\n  // rc should contain the number of bytes read in this operation.\n  // do stuff...\n\n  // next read\n  rc = in.read(buffer); \n}\n</code></pre>\n"},{"is_accepted":true,"score":5,"answer_id":9588458,"body":"<p>You ... read 512 bytes at a time.</p>\n\n<pre><code>char[] myBuffer = new char[512];\nint bytesRead = 0;\nBufferedReader in = new BufferedReader(new FileReader(\"foo.txt\"));\nwhile ((bytesRead = in.read(myBuffer,0,512)) != -1)\n{\n    ...\n}\n</code></pre>\n"}],"is_answered":true,"view_count":12029,"accepted_answer_id":9588458,"answer_count":3,"score":2,"creation_date":1331053380,"question_id":9588348,"title":"Java - Read file by chunks?","body":"<p>I know how to read a file by bytes but cannot find a example how to read it in chunks of bytes. I have a byte array, and i want to read the file by 512bytes and send them over a socket.</p>\n\n<p>I have tried by reading total bytes of file and then subtracting 512 bytes until i got a chunk that was less than 512 bytes and signaled EOF and end of transfer.</p>\n\n<p>I am trying to implement a TFTP, where data is sent in 512 byte chunks.</p>\n\n<p>Anyhow would be thankful for a example.</p>\n"},{"tags":["java","io","jms","message-queue"],"answers":[{"is_accepted":true,"score":2,"answer_id":11666344,"body":"<p>Event driven solution is certainly a good option here, so JMS would probably be a good solution. </p>\n\n<p>But you should keep in mind that if your consumers won't keep up with producer and you'll be using persistent delivery, messages will be stored on your hard drive and this will cause disk IO. But I think this won't be a problem, as you can always increase number of concurrent consumers, or even use cluster (which is really easy to configure with ActiveMQ for example) to keep up with load.</p>\n\n<p>To summarize, I think that JMS would be a great solution to your problem, as you won't need to actively poll filesystem for changes and makes it really easy to scale your processing application.</p>\n\n<p>If you are interested in topic of integration you might visit <a href=\"http://www.enterpriseintegrationpatterns.com\" rel=\"nofollow\">enterprise integration site</a> and read a extremely good book by Gregor Hohpe and Bobby Woolf on this topic. You can find link to it at the mentioned site. In it you'll find all pros and conses of both approaches as well as familiarize yourself with others available. Anyways messaging is definitely great way to go.</p>\n\n<p>You might consider using <a href=\"http://camel.apache.org/\" rel=\"nofollow\">camel framework</a> as an implementation of mentioned there patterns.</p>\n"}],"is_answered":true,"view_count":1095,"accepted_answer_id":11666344,"answer_count":1,"score":2,"creation_date":1343291582,"question_id":11665371,"title":"java message queue or read file manually","body":"<p>We have seperate Java instances program processing raw weblog like that:</p>\n\n<pre><code>jvm instance 1 read fileA --&gt; process\njvm instance 2 read fileA ---&gt; process\njvm instance 3 read fileA ---&gt; process\n....\n</code></pre>\n\n<p>I think when the number of jvm instance increase , the number of <code>disk IO</code> process 'll increase. And there comes a time this solution is can not work propertly.</p>\n\n<p>So can anyone tell me another solution <code>for reduce the disk IO</code>. </p>\n\n<p>I think an ideal is using a JMS server (like Apache ActiveMQ) to read file an store in queue and process.</p>\n\n<p>have any problem if i use JMS ???</p>\n\n<p>Please kindly help me.</p>\n"},{"tags":["java","networking","io","bytebuffer"],"answers":[{"is_accepted":false,"score":-1,"answer_id":8258768,"body":"<p>Umm, realize that your handling of the variable i is not correct..</p>\n\n<pre><code>Iteration 0: i=0\nIteration 1: i=PACKET_SIZE\n...\n...\nIteration n: i=PACKET_SIZE*n\n</code></pre>\n"},{"is_accepted":true,"score":4,"answer_id":8259212,"body":"<p>It doesn't look like you're reading data from the file properly.  When reading data from a stream in Java, it's standard practice to read data into a buffer.  The size of the buffer can be your packet size.</p>\n\n<pre><code>File fileToSend = //...\nInputStream in = new FileInputStream(fileToSend);\nOutputStream out = //...\nbyte buffer[] = new byte[PACKET_SIZE];\nint read;\nwhile ((read = in.read(buffer)) != -1){\n  out.write(buffer, 0, read);\n}\nin.close();\nout.close();\n</code></pre>\n\n<p>Note that, the size of the buffer array remains constant.  <strong>But--</strong> if the buffer cannot be filled (like when it reaches the end of the file), the remaining elements of the array will contain data from the last packet, so you must ignore these elements (this is what the <code>out.write()</code> line in my code sample does)</p>\n"}],"is_answered":true,"view_count":1972,"accepted_answer_id":8259212,"answer_count":2,"score":5,"creation_date":1322144770,"question_id":8258592,"title":"Java Read File Larger than 2 GB (Using Chunking)","body":"<p>I'm implementing a file transfer server, and I've run into an issue with sending a file larger than 2 GB over the network. The issue starts when I get the <code>File</code> I want to work with and try to read its contents into a <code>byte[]</code>. I have a for loop :</p>\n\n<pre><code>for(long i = 0; i &lt; fileToSend.length(); i += PACKET_SIZE){\n    fileBytes = getBytesFromFile(fileToSend, i);  \n</code></pre>\n\n<p><br /> where <code>getBytesFromFile()</code> reads a <code>PACKET_SIZE</code> amount of bytes from <code>fileToSend</code> which is then sent to the client in the for loop. <code>getBytesFromFile()</code> uses <code>i</code> as an offset; however, the offset variable in <code>FileInputStream.read()</code> has to be an <code>int</code>. I'm sure there is a better way to read this file into the array, I just haven't found it yet.  </p>\n\n<p>I would prefer to not use NIO yet, although I will switch to using that in the future. Indulge my madness :-)</p>\n"}],"has_more":false}